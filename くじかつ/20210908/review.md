- a:文字列を不等号で比較可能。思いつかなければソートして順番を確認することも可能。

- b:条件通りに実装する。実装するだけの問題では特にミスに注意。

- c:1000は8の倍数であり、４桁以上の部分は考慮しなくて良い。３桁以下の場合は全探索可能。3，9の倍数判定など頻出。文字数が多いので愚直に数字をとって考えるのではまず無理と判断。

- d:素数判定をそれぞれの数で行うには、エラトステネスの篩でテーブルを作る方が早い。O(nloglogn)。テーブルを作ったら、2017ににている数かどうかを判定して、判定した結果を別のテーブルに記録。l,rの連続する区間のクエリで累積和で各クエリに対してO(1)で処理。

- e:
    1. まず、全ての場合を愚直に試すことは不可能。まとめられる処理がないかを探しながら実験していた。照らせる区間をグループ化することで効率化できないかを考えたが、グループ内でもテラス領域が異なるのでまとめて計算が無理そうであると断念。発想を変えて、各マスに対してO(1)できないか考えて、そのますを照らす個数がわかれば、その中で一つだけが点いていれば十分なので2^n-1でO(logn)で求めることが可能。照らす部分と関係ない部分は付いていても点いていなくてもどちらでも良いので2^(残りの空白ます)。
    2. あとはますを照らすテーブルを制約の時間内で作成したい。O(hw)までは行けそうなので、全てのますを見ていくことを考えた。
        1. 初手では計算量見積もりを勘違いし、各ますから4方向に伸ばしてTLE。
        2. 深く考察をせずに、再帰関数が遅いと誤判断しwhile文に変えて実装してTLE.
        3. 繰り返し二乗法できる部分で節約したがまだTLE.
    3. 一度計算量の見積もりをし直した結果、誤った考察であることに気がつく。一度見たますを見ないようにしたい。
        1. 左上から見ていくので、上と左は再度見る必要がない。右、下進むことを分けてそれぞれ行き着くところまでをまとめてその要素数を配列に入れていく。
        2. これで全体の計算量はO(hw)になったがまだTLE。
        3. 拉致が開かないので、コードテストで最大ケースを代入して計算量削減に入る。
        4. 実装ミスで一度見たますをスキップできていなかったが、修正してもTLE.
        5. for 文に変えてみても依然としてギリギリ間に合わない、
    4. 自分が修正している関数がそもそも遅いのかを確認するために部分ごとに時間を計った場合に、該当箇所は時間に間に合っていた。後半最後の1の計算部分がオーバーしていた。
        1. 繰り返し二乗法していたのであとは、まとめられる部分はまとめて計算できることを思いつく。照らされる数が同じであれば、残りの空白のますも同じ数であるため。
        2. ようやくTLEが解消した。結局、関数部分の速度の問題ではなかった。一度見たマスからは探索しないことと、計算部分を効率化することが寄与した。
    総括として、計算量改善する際には原因を決めつけないで実際にテストしながら行うべきである。固定観念を捨てないとデバッグが進まない。


