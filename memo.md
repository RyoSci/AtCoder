# <span style="color: yellow; ">デバッグチェックリスト</span>

- このリストだけでは分からない時は一旦お手上げ、諦めて次の問題にいく。
準備していなかったパターンが出ただけ、全く問題ない。
以下の記事参照
https://qiita.com/e869120/items/8be6521e72025d7b2a13

<br/>

## 1. まず簡単に確認できることは行う

1. まずはサンプルケースが合うかを確認する
2. 自作でサンプルケースを<span style="color: red;">5件</span>は作成して確認する
    - N が小さいケース 
    - N が大きいケース（答えがすぐ作れる場合） 　
    - 自作ケース（N=3〜5 など、手計算が手間でなければ） 　
    - コーナーケース（1 分くらいは考える） 　
    - 計算量解析（最悪ケースで TLE しないか）
3. 出力、途中の配列が意図通りになっているか確認
4. デバッガも必要に応じて使う
5. それでも分からない場合は具体的なリストを確認していく

<br/>

## 2.自分が過去にやった実装ミスを疑う
1. 入出力が誤っている
    - 文字列の空白区切り
        - ABC244D
    - 入力行数のミス
        - 行数がnでなくmであったなどよくやる
2. 添字を間違える
    - 特に2次元以上の配列の初期化、アクセスを間違える
    - 配列街参照を起こす

3. テストケースを実施していない ABC244D

4. コピペミスでWAとなるコードを出していないか

5. INFの初期化ミス 
    - ABC243E

0. INFの初期化が足りない
    - ABC258D

6. 演算ミス「+」と「*」

7. 変数が多くなると、間違う。特に添字
    - ループの添字で入力の変数を更新してしまう時もある

8. -1をfalseとして扱ってしまう。0がfalse

9. 素数判定関数の1の時の処理のし忘れ

10. UnionFind
    - できればテンプレートを使う
    - find時に親にたどってない
    - union時に同じグループの時のスキップ忘れ

11. 二分探索時の番兵忘れ

12. 同じ処理はコピペしがちであるが、特にグラフ問題の時に、添字が修正できていない

13. dp
    - 添字ミス
    - 初期化ミス
    - 遷移ミス
        - 2状態くらいの少ない遷移の時に、0/1を手書きしている時にうち間違える
        - 可能であればループで回す
        - そもそもの誤解・嘘解法というのもある
    - dpで通り数を数える時に、modが指定されていない場合に上限値を超えてマイナスになることがある。ABC200d

14. ダイクストラ
    - ゴミをcontinueしていない
    - 負閉路あると使えない
    - 負辺があっても使えない　ポテンシャル

15. ワーシャルフロイド
    - 負閉路は自分自身への距離が負なら確認できる

16. 貪欲法的なアイデアは漏れがないか？思い違いはないか？
    - 周期性を最大限利用するのはOKか？
        - ワープしてよいと思っていたが、１つ手前でとまってシミュレーションする必要があった ABC175D

17. デッバグ時の設定が消えていない
    - プリントデバッグ
    - 入力消してテストケース作った場合

18. GCD初期化, LCM壊れるほど桁が大きくなることでTLE
    - 全体を表現するのに0で十分、全てを掛け合わせたり、lcmをとる必要はない

19. 値の初期化ミス、dpのときの-1なのか0なのか
    - 高次元になる時は配列の中身を全部出力したほうが早い

20. 0除算。ABC245D

21. 既に宣言している関数や、組み込み関数名等を重複して命名してしまう。それっぽい関数がありそうな名前なら「_」等つける。

22. 周期性を利用したい時に、端が意図と異なる。
    - あまりゼロの時の切り捨て
23. dpで通り数を数える時に、modが指定されていない場合に上限値を超えてマイナスになることがある。ABC200d

24. ABC246C 元々はTLEするほど大きい変数（変数k）を減らした後にループを回す時に何回回せばよいかを未確認で実装しているケースが多い。

25. 場合ミスは１から整理しないと勘違いに気付くには厳しい。できれば探索で解決したい。

26. globalに宣言してmainで変更したつもりが宣言し直していて別の変数としてそれぞれ扱われている。

27. dpの遷移を手打ちする時は、処理忘れ、状態添字間違え等頻発するので注意。

28. 文字列の連結で桁が２桁以上になる場合にリストと異なる。

29. 演算の順序、ビット演算の時も注意

30. WAの件数が綺麗に分かれていそうなら条件分岐内を確認する

31. 二次元引数の辞書でTLE->1次元に変換するか、配列で

32. dequeでpopleftするところをpopしていた

33. 「*」 「+」 のタイポ
- タイポはあとで確認するのが面倒
- 関数を積極的に使う

34. if判定の and or
- (x, y) != (nx, ny)の判定

35. 二次元の探索ならbfsで可能ならbfsでやるべき

36. UnionFindで二次元の場合かけるのを逆
- i*w + j

37. 座標のUFは左端から右と下をmergeしていくのでも良い場合がある

38. 状態数が増えることがわかっていない
- 深さは低くても分岐する場合は指数関数的に爆発する
- 状態数が不要であることを確認する

39. 再帰関数でなくても状態数が爆発することがあることをイメージできてない

40. ループの変数名を変えてしまう
    - ループ内に限らないが、2次元以上のループの時に上の階層の変数が変更されたままになる

41. から文字列を数字変換する関数をかけるとエラーになる
    - int, stoll

42. cppの慣れ不足によるミス
    - テンプレートの挙動を理解せずに使っている
        - デバッグ
        - 整数がllになっていない
    - 負の定義域がない
        - sizeだと符号なしで返ってくる
43. 二分探索前にsortしてない

44. python->cpp変換にchatgptを使用した場合の変換ミス
    - 変換ミスなのか、元々のソースがバグを埋め込んでいいるのか確認
    - 変換ミスの場合もあり得る
        - うまく変換できない処理がある
            - 疎な二次元配列の入力

<br/>

## 3. リストを見る 
- 以下は記事引用
1. 入出力の形式を間違える（頻出度：:star:3）
    - N と K などの入力順を間違える（特に入力される値が 2 3 個しかない場合に注意）
    - 入力が N−1N−1 行のところを NN 行入力してしまう（木構造が与えられる場合など）
    - Yes と出力すべきところを間違って YES と出力してしまう
    - 構築問題（答えの一例を出力させる問題）で、出力の順序や形式を間違える

2. 型（int・long long など）を間違える（頻出度：:star:4）
    - 入力が小数であるにも関わらず、int などの整数型で入力を行ってしまう
    - 入力が 2 文字以上の文字列であるにも関わらず、1 つの char 型で入力を行ってしまう
    - 10191019 を超える入力に対して long long などの整数型を使ってしまう（本当は string などの文字列型で入力しなければならない1）

3. 添字を間違える（頻出度：:star:5）
   - j であるはずのものが par になってしまう
   - par であるはずのものが 1 になってしまう
   - 1 であるはずのものが par になってしまう
   - 特に変数の種類が増えた場合に、同じ変数を 2 回以上定義する
   - 「+」 と 「-」、あるいは ++ と -- を逆にする

4. 境界や不等号を間違える（頻出度：:star:4）

5. 命令を 1 個書き忘れる（頻出度：:star:3）

6. 場合分けを忘れる（頻出度：:star:3）

7. オーバーフロー・誤差によるバグ（頻出度：:star:2）

8. 配列外参照をする（頻出度：:star:3）

9. 初期化を忘れる（頻出度：:star:2）

10. そもそも解法が間違っている（頻出度：:star:5）

<br/>

よくやった！実装パートの確認完了！
ここまで確認して実装ミスが見つからなかったら、考察ミスに取り掛かろう

<br/>


 # <span style="color: lightblue; ">再考察する前に読む</span>
- まずは落ち着く
    - 焦っている時はまともな思考はできないのでまず深呼吸
        - 過去の自分のデータからも言える。
        - 心拍数が120超えたらかなり注意。
        - 簡単な問題のはずなのに詰まったら間違いなく考察ミス
    - 簡単な問題でミスったとしても全く問題ない。固執せずに次の問題にいくべき
        - パフォーマンス的にも、思考整理的にも
    - 明らかに簡単な問題で10分つまったら方針が良くない。
        - ABCの場合は特に解法ガチャをやるイメージ  
    - 焦っている時は一つのことの確認は鋭くなるが、広範囲の選択肢が見えなくなる傾向がある
    - 焦りやすい過去の自分に対策の成果を見せるチャンス
    - 大前提遅れを取り返そうと思わない
    - 早解きできなくても問題ない、考察が間に合わないのは問題ない
    - 理解をすっ飛ばしても絶体に解けない
    - 焦って混乱するのが一番よくない。1から状況整理しよう！
    - 遅くなったとしても1から確認すれば解ける

- 整理にかかる
    - ソースをいじることをやめる
        - 修正は一旦保留
    - 原因が考察か実装か切り分ける
    - まずは実装を疑う デバッグチェックリストを確認していく
    - 実装で思い当たらない時は１から考察し直す
        - ノートに帰って前提から確認
        - 考察し直せるまで実装は保留
    - どこまでが分かっていて、どこからが分かっていないのかをノートに書く
    - すぐに解決できない時は0から考え直す
    - 冷静になっても考察できない時は考察フレームワークに目を通す
    - もし次の問題を見ていないなら、次に行くのも一つの選択
        - 成功した経験も2回はある
    - 絶対に自分が自信も持てるところと持てないところを整理する
        - 自信がないならそれは嘘解法の可能性が高いのでやり直すだけ
        - 自信があるのに間違っているのは実装ミスの可能性も
            - 考察を疑っていたが、実装ミスしていた時もある ABC244D
<br/>


<br/>

# 考察フレームワーク（初手での考察・再考察で目処がたたなくなった時に確認する）
- 考察に詰まった時のチェックリスト
    - 考察ミス
        - [ ] 誤読や見落としはないか
        - [ ] サンプルを正しく理解したか
        - <span style="color: red;"> [ ] 仮定に思い込みはないか
</span>
        - <span style="color: red;"> [ ] 制約から逆算できないか
</span>
            - 10^12 平方根を検討
            - 
    - 考察不足
        - [ ] 愚直解からのステップで計算量改善は考えたか
            - そのステップで整理できたことがある
        - [ ] 数式を用いた考察をしたか
            - 状態が見えて整理される時がある
        - [ ] 探索の利用を検討したか
            - 制約ギリギリでも探索が想定解の時もあった
            - 計算量見積もりミスで、本当は全探索できた
                - 制約確認ミス
                - グラフの握手の定理
            - 探索から状態のかぶりからdpまで考える
            - dfs, 2bit, 順列, １文字固定、 真ん中固定
        - [ ] 規則性が見つからず式一発でできない時は探索を有効活用する
        - [ ] 貪欲のルールが全く見当がつかない時は探索、状態がまとめられそうならdpを検討する

    - 以上に問題がない場合
        - [ ] 典型考察ガチャ
        - [ ] 解法ガチャ (二分探索・DP・ダブリングなど)
        - [ ] 実験・テストケース作成

- 典型考察 (条件の言い換え)
    - 連続区間
        - 尺取
        - 二分探索
        - 累積和
            - f(r)-f(l) = r-lのように式変形すると見通しが良くなることも
    - 逆から考える　
        - UF (+ 中央/両側)
        - 大きい順に/小さい順に
    - 主客転倒する
    - 独立に考える (x,y・bit)
    <!-- - プロットする (二次元データなど) -->
    - 余事象を考える
    - 同一視する (DP の状態など)
    <!-- - 単純化する (≒貰える仮定は貰う) -->
    <!-- - 相対化する (変化量に着目する) -->
    - 単調増加、単調減少に注目 (二分探索・尺取り)
    - できるできないの境界がある（決めうち二分探索）
    - 周期性を考える (mod 、ダブリング)
    - 不変量を考える (ゲーム・貪欲法)
    - パリティを考える (グリッドなど)
    - ソートしても問題ない時はソートする
        - 組み合わせ
        - iに依存しない
    - 1手先の最善が局所最適な場合は全探索/dpを考慮する
        - DAGに落とし込めるならdpも検討
    - 真より大のような条件の場合、同じ数をまとめて考えることも多い

    - 貪欲法
        - ２変数になるとルールが分かりにくくなる、一旦片方の変数でルールが押せないか探すのも良いかもしれない。
            - 変数を決め打つと残りの変数は貪欲に求めるれることも多々ある。
            - 変数決めて、二分探索や不等式で境界を超える最小値を定数時間で求めることも可能
        - 思いつく正攻法の進め方でなくて、逆から等進め方を変えたら貪欲ルールが見つかることもありそう
        - ABC137Dの「真のルールが必要」というのが分かりやすかった。

    - 合成関数を逐一求める場合の計算量改善
        - 合成後の関数の出力を考えるのは割と典型
    - min, max関数の問題の場合はグラフ化して考えた方がわかりやすい
    
<br/>

 ## 実装テク
 - 周期性がある時に2周を配列に持つと実装が楽になる時がある
    - 環状の時
    - 同じ配列を繰り返しワープする時

- 二分探索
    - while left + 1 < rgiht　で隣同士になったら終了。最後回すかどうかが分からなくなるので再確認
    
    - l側がtrueなのか、r側がtrueのなかは確認最後まで境界を挟んだt/fは変わらないように初期値を設定
        - ok=0も考えらる場合はngに-1を入れたこともある
    - 一見連続ではなく、離散的な値を取りそうなので使えないかと思いきや使える場合もある
        - 離散値もOKと判定できる条件に落とし込む
            - それ以下に必要な回数が入力値以下/以上などの場合
    - 値を求める場合は、区間ないに必ず解が含まれるように縮めることで単調性がなくても連続関数であれば解ける。中間値の定理。
    - 二分探索がオーバーキルの場合もある。不等式の評価が可能であればO(1)に。ただ実装もほとんどバグらせない自信があるので絶対ではない。
    - 文字列の一致数など、使える場合は多いので計算量に困ったら考えるのもありな気がする

- 実装重い問題
    - 時間かかっても良いので、削れる処理は削る
    - 何が欲しい状態かをメモするなりして整理する

- nCk 
    - 階乗ををメモする
    - k < 0, n < kのときは0を返す実装の方が境界等を考えなくて済む

- 繰り返し二乗法
    - while(p) の中でpが奇数の時だけrestにxをかけて、最終的にrestを返す

- bitdp
    - 制約から順列で無理か確認する。こっちのほうが実装楽。
    - dp[par][j]:=集合iまで見て、最後に行ったのがj
    - 遷移はjからkに行く時に、jはiとandが取れて、kはiとandが取れていない場合のみ更新する。

- 和と排他的論理和の関係
    - A+B = A^B + 2*(A & B)

- 尺取法
    - テンプレート　伸ばせるだけ伸ばして、１個づつ縮める
        ```python
        r = 0, now = 1
        for l in range(n):
          while r < n and now *= a[r]:
              now *= a[r]
              r += 1
          ans = (l - r)
          if l == r:
              r += 1
          else: now /= a[l]
        ```
    - whileの条件が次のrで更新するときもある

- ダイクストラ法
    - Mlog(M)
        - 辺が疎の時 M<N^2
            - Mlog(N)
        - 辺が密の時 M>=N^2
            - Mlog(N) >= N^2log(M)
    - ゴミをスキップするのを忘れない
        - while
            - if dis[v] < d: contine

    - 愚直の方はN^2
        - リストで距離と到達済みフラグの配列を持ち各点ごとにフラグを見ていく。

- 小数の扱い
    - 一番は文字列、整数で扱う
    - 分数
        - 可能なら分母を払って管理
        - 計算量にゆとりがあるなら有理数型
        - 文字列で取れるならdecimalもあり
    - 丸め方は本番でやったことないので余りお勧めしない
        - やるなら目的値に近い数値で丸めるようにするround

- 直線の方程式
    - ２点の座標がわかれば一発で式化できて、軸と並行の時も対応可能
    - dx*(y -y1) = dy*(x - x1)

- 直線上にあるか
    - 直線の式に代入
    - ２直線のベクトルのcosθが-1,1になる
    
- 回転
    - 原点に戻してから考えた方がわかりやすい可能性あり
    
    - 複素平面で回転対称の座標に回転させる基底の座標をかける
    - 逆関数で角度求めて、素直に回転させる

- 点と直線の距離
    - ベクトルで考える
    - 複素平面で回転させて直線をx軸に一致させて、y座標を見る

- dp
    - 場合わけが面倒になったら状態数を増やすことも想定に入れる。
    - 遷移が多い時はループを増やす
    - まずは多次元で遷移を考えて次元を落としても問題ない場合は落とした方が実装ミスが少ない
    - 低次元だと不要な/不適切な遷移を見落としてしまうこともあるので注意

- UF
    - 辺を壊すことができない
        - 逆から構築していく
        - クエリをまとめてやる
        - 辺追加にクエリも混ぜてできている段階でのクエリを出力
    - 個数というのが一つのキーワードになる

- サイクル検出
    - 無向グラフ
        - UF
            ```python
            for par in range(n):
                for e in edges[par]:
                    a, b = e
                    if same(a, b):
                        # サイクル検出
                    else:
                        unite(a, b)
            ```
    - 有向グラフ・無向グラフ
        - dfs
            ```python
            def dfs(par, root):
                seen[par] = 1
                hist.append(par)
                for chi in g[par]:
                    # 無向辺の場合逆流を防ぐ
                    if chi == root: 
                        continue
                    # 完全終了した場合はスルー
                    elif finished[chi]: 
                        continue
                    # サイクル検出
                    elif seen[chi] and not finished[chi]:
                        # サイクル検出した時の処理
                        pass
                        # サイクル復元
                        while len(hist)>0:
                            tmp = hist.pop()
                            if tmp == chi:
                                break
                    else: 
                        dfs(chi, par)
                len(hist)>0:
                    hist.pop()
                finished[par] = 1

            ```
- gcd, lcm(忘れた時用)
    ```python
    def gcd(a, b):
        if b == 0:
            return a
        return gcd(b, a%b)

    def lcm(a, b):
        return a // gcd(a, b) * b

    ```
- 負の割り算
    - pythonで負の数を切り捨てる場合は-♾の方向に切り捨てられるので注意
    - 以下を参照
        - https://it-for-pharma.com/abc155-d-%E8%B2%A0%E3%81%AE%E6%95%B0%E3%81%8C%E7%B5%A1%E3%82%80%E9%99%A4%E7%AE%97%E3%81%AE%E5%88%87%E3%82%8A%E6%8D%A8%E3%81%A6-and-%E5%88%87%E3%82%8A%E4%B8%8A%E3%81%92%E3%81%AE%E6%95%B4%E7%90%86
    - cppの場合は原点に近づくように切り捨てられる

- C++ set.lower_boundでindexを求めたい時の対処法
    - 参考ABC306F
    - PythonのSortedListを使う
        - pypyだと下の方針と0.7秒くらいしか変わらなかった
    - C++の場合は以下の手順
        - 座標圧縮
            - 座標圧縮した後のindexを使用する
        - BIT(fenwick_tree)を使う
            - addでindexに対する+-ができる
            - sumであるindex間の個数を求めることができる

- Decimalはpypy遅いのでまずは有理数型を検討する

- 有理数型も使わない関数は減らさないと遅くなる
 ## 練習時の意識
- できる限り手書きコピーは減らす
    - 添字の場合わけミスは結構やりがち

- 本来OKのはずの答えがNGになっているとそれまでのどこかでミスってる可能性大

- 緩い制約の時の考察思いついていない感覚ある
- 本番中に知らない知識を調べるのはやめる
- 実装を急がない。結局ミスしてデバッグするときの方が時間がかかる
- 毎行の処理で自信を持って処理を書く
- 大きい順、小さい順に行う、ソートするなどして操作が簡潔になる場合がある
- 実装を簡潔にするために、同じ変数でごちゃごちゃしないで、変数ごとに役割を分ける
- 構成問題は実験に限る
    - 極端なケースや、シンプルなケースで構築できることも多い
    - 制約から逆算もできるかもしれない
- 回転する問題は１点固定して考えると進みやすい
- 循環する場合は配列を円環で考えると進みやすい

## 定数倍高速化
- min,maxではなく条件式で実行
- 関数呼び出しを減らす
- 訪問済みはリストで管理
- ３次元配列を１次元配列にする
    - ソースはqiitaのお気に入りに
    - ２次元配列の場合も同様
    - python固有の関数、ライブラリを使っているならばこの方針
    - cppでも同様のことが可能ならば、書き直した方が早い（ABC261E:再提出まで５分程度）
- 二次元で情報管理しているのを無理やり一次元にする
    - queueなど
- 文字など辞書を使う必要がない場合がある