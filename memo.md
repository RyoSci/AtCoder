# <span style="color: yellow; ">デバッグチェックリスト</span>

- このリストだけでは分からない時は一旦お手上げ、諦めて次の問題にいく。
準備していなかったパターンが出ただけ、全く問題ない。
以下の記事参照
https://qiita.com/e869120/items/8be6521e72025d7b2a13

<br/>

## 1. まず簡単に確認できることは行う

1. まずはサンプルケースが合うかを確認する
2. 自作でサンプルケースを<span style="color: red;">5件</span>は作成して確認する
    - N が小さいケース 
    - N が大きいケース（答えがすぐ作れる場合） 　
    - 自作ケース（N=3〜5 など、手計算が手間でなければ） 　
    - コーナーケース（1 分くらいは考える） 　
    - 計算量解析（最悪ケースで TLE しないか）
3. 出力、途中の配列が意図通りになっているか確認
4. デバッガも必要に応じて使う
5. それでも分からない場合は具体的なリストを確認していく

<br/>

## 2.自分が過去にやった実装ミスを疑う
1. 入出力が誤っている
    - 文字列の空白区切り
        - ABC244D
    - 入力行数のミス
        - 行数がnでなくmであったなどよくやる
2. 添字を間違える
    - 特に2次元以上の配列の初期化、アクセスを間違える
    - 配列街参照を起こす

3. テストケースを実施していない ABC244D

4. コピペミスでWAとなるコードを出していないか

5. INFの初期化ミス ABC243E

6. 演算ミス「+」と「*」

7. 変数が多くなると、間違う。特に添字
    - ループの添字で入力の変数を更新してしまう時もある

8. -1をfalseとして扱ってしまう。0がfalse

9. 素数判定関数の1の時の処理のし忘れ

10. UnionFind
    - できればテンプレートを使う
    - find時に親にたどってない
    - union時に同じグループの時のスキップ忘れ

11. 二分探索時の番兵忘れ

12. 同じ処理はコピペしがちであるが、特にグラフ問題の時に、添字が修正できていない

13. 

<br/>

## 3. リストを見る 
- 以下は記事引用
1. 入出力の形式を間違える（頻出度：:star:3）
    - N と K などの入力順を間違える（特に入力される値が 2 3 個しかない場合に注意）
    - 入力が N−1N−1 行のところを NN 行入力してしまう（木構造が与えられる場合など）
    - Yes と出力すべきところを間違って YES と出力してしまう
    - 構築問題（答えの一例を出力させる問題）で、出力の順序や形式を間違える

2. 型（int・long long など）を間違える（頻出度：:star:4）
    - 入力が小数であるにも関わらず、int などの整数型で入力を行ってしまう
    - 入力が 2 文字以上の文字列であるにも関わらず、1 つの char 型で入力を行ってしまう
    - 10191019 を超える入力に対して long long などの整数型を使ってしまう（本当は string などの文字列型で入力しなければならない1）

3. 添字を間違える（頻出度：:star:5）
   - j であるはずのものが i になってしまう
   - i であるはずのものが 1 になってしまう
   - 1 であるはずのものが i になってしまう
   - 特に変数の種類が増えた場合に、同じ変数を 2 回以上定義する
   - 「+」 と 「-」、あるいは ++ と -- を逆にする

4. 境界や不等号を間違える（頻出度：:star:4）

5. 命令を 1 個書き忘れる（頻出度：:star:3）

6. 場合分けを忘れる（頻出度：:star:3）

7. オーバーフロー・誤差によるバグ（頻出度：:star:2）

8. 配列外参照をする（頻出度：:star:3）

9. 初期化を忘れる（頻出度：:star:2）

10. そもそも解法が間違っている（頻出度：:star:5）

<br/>

よくやった！実装パートの確認完了！
ここまで確認して実装ミスが見つからなかったら、考察ミスに取り掛かろう

<br/>


 # <span style="color: lightblue; ">再考察する前に読む</span>
- まずは落ち着く
    - まず深呼吸
    - 焦っている時は一つのことの確認は鋭くなるが、広範囲の選択肢が見えなくなる傾向がある
    - 焦りやすい過去の自分に対策の成果を見せるチャンス
    - 大前提遅れを取り返そうと思わない
    - 早解きできなくても問題ない、考察が間に合わないのは問題ない
    - 理解をすっ飛ばしても絶体に解けない
    - 焦って混乱するのが一番よくない。1から状況整理しよう！
    - 遅くなったとしても1から確認すれば解ける

- 整理にかかる
    - ソースをいじることをやめる
        - 修正は一旦保留
    - 原因が考察か実装か切り分ける
    - まずは実装を疑う デバッグチェックリストを確認していく
    - 実装で思い当たらない時は１から考察し直す
        - ノートに帰って前提から確認
        - 考察し直せるまで実装は保留
    - どこまでが分かっていて、どこからが分かっていないのかをノートに書く
    - すぐに解決できない時は0から考え直す
    - 冷静になっても考察できない時は考察フレームワークに目を通す
    - もし次の問題を見ていないなら、次に行くのも一つの選択
        - 成功した経験も2回はある
    - 絶対に自分が自信も持てるところと持てないところを整理する
        - 自信がないならそれは嘘解法の可能性が高いのでやり直すだけ
        - 自信があるのに間違っているのは実装ミスの可能性も
            - 考察を疑っていたが、実装ミスしていた時もある ABC244D
<br/>


<br/>

# 考察フレームワーク（初手での考察・再考察で目処がたたなくなった時に確認する）
- 考察に詰まった時のチェックリスト
    - 考察ミス
        - [ ] 誤読や見落としはないか
        - [ ] サンプルを正しく理解したか
        - <span style="color: red;"> [ ] 仮定に思い込みはないか
</span>
        - <span style="color: red;"> [ ] 制約から逆算できないか
</span>
    - 考察不足
        - [ ] 愚直解からのステップで計算量改善は考えたか
            - そのステップで整理できたことがある
        - [ ] 数式を用いた考察をしたか
            - 状態が見えて整理される時がある
        - [ ] 探索の利用を検討したか
            - 制約ギリギリでも探索が想定解の時もあった
            - 計算量見積もりミスで、本当は全探索できた
                - 制約確認ミス
                - グラフの握手の定理
            - 探索から状態のかぶりからdpまで考える
            - dfs, 2bit, 順列, １文字固定、 真ん中固定
        - [ ] 規則性が見つからず式一発でできない時は探索を有効活用する
        - [ ] 貪欲のルールが全く見当がつかない時は探索、状態がまとめられそうならdpを検討する

    - 以上に問題がない場合
        - [ ] 典型考察ガチャ
        - [ ] 解法ガチャ (二分探索・DP・ダブリングなど)
        - [ ] 実験・テストケース作成

- 典型考察 (条件の言い換え)
    - 逆から考える　UF (+ 中央/両側)
    - 主客転倒する
    - 独立に考える (x,y・bit)
    <!-- - プロットする (二次元データなど) -->
    - 余事象を考える
    - 同一視する (DP の状態など)
    <!-- - 単純化する (≒貰える仮定は貰う) -->
    <!-- - 相対化する (変化量に着目する) -->
    - 単調増加、単調減少に注目 (二分探索・尺取り)
    - できるできないの境界がある（決めうち二分探索）
    - 周期性を考える (mod 、ダブリング)
    - 不変量を考える (ゲーム・貪欲法)
    <!-- - パリティを考える (グリッドなど) -->

<br/>
